{"ast":null,"code":"/**\n * A collection of string matching algorithms built with React Select in mind.\n */\n// Option type from React Select and similar libraries.\n\n/**\n * Filters React Select options and sorts by similarity to a search filter.\n * Handles partial matches, eg. searching for \"Waberg High\" will find \"Raoul\n * Wallenberg Traditional High School\". Case insensitive. Ignores\n * non-alphanumeric characters.\n *\n * @param  options  An unfiltered list of Options.\n * @param? filter  A string to compare against Option labels.\n * @param? substitutions  Strings with multiple spellings or variations that we\n *           expect to match, eg. accented characters or abbreviated words.\n *\n * @return A filtered and sorted array of Options.\n */\nexport function filterOptions(options, filter, substitutions) {\n  // If the filter is blank, return the full list of Options.\n  if (!filter) {\n    return options;\n  }\n\n  var cleanFilter = cleanUpText(filter, substitutions);\n  return options // Filter out undefined or null Options.\n  .filter(_ref => {\n    var {\n      label,\n      value\n    } = _ref;\n    return label != null && value != null;\n  }) // Create a {score, Option} pair for each Option based on its label's\n  // similarity to the filter text.\n  .map(option => ({\n    option: option,\n    score: typeaheadSimilarity(cleanUpText(option.label, substitutions), cleanFilter)\n  })) // Only include matches of the entire substring, with a slight\n  // affordance for transposition or extra characters.\n  .filter(pair => pair.score >= cleanFilter.length - 2) // Sort 'em by order of their score.\n  .sort((a, b) => b.score - a.score) // …and grab the original Options back from their pairs.\n  .map(pair => pair.option);\n}\n/**\n * Scores the similarity between two strings by returning the length of the\n * longest common subsequence. Intended for comparing strings of different\n * lengths; eg. when matching a typeahead search input with a school name.\n\n * Meant for use in an instant search box where results are being fetched\n * as a user is typing.\n *\n * @param  a  The longer string (though, we flip them if it's shorter).\n * @param  b  The shorter string, eg. a typeahead search input.\n *\n * @return The length of the longest common subsequence. Higher scores indicate\n *           closer matches.\n */\n\nexport function typeaheadSimilarity(a, b) {\n  var aLength = a.length;\n  var bLength = b.length;\n  var table = [];\n\n  if (!aLength || !bLength) {\n    return 0;\n  } // Ensure `a` isn't shorter than `b`.\n\n\n  if (aLength < bLength) {\n    [a, b] = [b, a];\n  } // Early exit if `a` includes `b`; these will be scored higher than any\n  // other options with the same `b` (filter string), with a preference for\n  // shorter `a` strings (option labels).\n\n\n  if (a.indexOf(b) !== -1) {\n    return bLength + 1 / aLength;\n  } // Initialize the table axes:\n  //\n  //    0 0 0 0 ... bLength\n  //    0\n  //    0\n  //\n  //   ...\n  //\n  // aLength\n  //\n\n\n  for (var x = 0; x <= aLength; ++x) {\n    table[x] = [0];\n  }\n\n  for (var y = 0; y <= bLength; ++y) {\n    table[0][y] = 0;\n  } // Populate the rest of the table with a dynamic programming algorithm.\n\n\n  for (var _x = 1; _x <= aLength; ++_x) {\n    for (var _y = 1; _y <= bLength; ++_y) {\n      table[_x][_y] = a[_x - 1] === b[_y - 1] ? 1 + table[_x - 1][_y - 1] : Math.max(table[_x][_y - 1], table[_x - 1][_y]);\n    }\n  }\n\n  return table[aLength][bLength];\n}\n/**\n * Apply string substitutions, remove non-alphanumeric characters, and convert\n * all letters to uppercase.\n *\n * eg. 'Scoil Bhríde Primary School' may become 'SCOILBHRIDEPRIMARYSCHOOL'.\n *\n * @param  input  An unsanitized input string.\n * @param  substitutions  Strings with multiple spellings or variations that we\n *          expect to match, for example accented characters or abbreviated\n *          words.\n *\n * @return The sanitized text.\n */\n\nexport function cleanUpText(input, substitutions) {\n  if (!input) {\n    return \"\";\n  } // Uppercase and remove all non-alphanumeric, non-accented characters.\n  // Also remove underscores.\n\n\n  input = input.toUpperCase().replace(/((?=[^\\u00E0-\\u00FC])\\W)|_/g, \"\");\n\n  if (!substitutions) {\n    return input;\n  }\n\n  var safeSubstitutions = substitutions; // For Flow.\n  // Replace all strings in `safeSubstitutions` with their standardized\n  // counterparts.\n\n  return Object.keys(safeSubstitutions).reduce((output, substitution) => {\n    var unsubbed = new RegExp(substitution, \"g\");\n    return output.replace(unsubbed, safeSubstitutions[substitution]);\n  }, input);\n}","map":{"version":3,"sources":["../../../src/lib/fuzzy-match-utils.tsx"],"names":["cleanFilter","cleanUpText","value","label","option","score","typeaheadSimilarity","pair","b","a","aLength","bLength","table","x","y","Math","input","safeSubstitutions","unsubbed","output"],"mappings":"AAEA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAA,aAAA,CAAA,OAAA,EAAA,MAAA,EAAA,aAAA,EAIK;AACV;AACA,MAAI,CAAJ,MAAA,EAAa;AACX,WAAA,OAAA;AACD;;AAED,MAAMA,WAAW,GAAGC,WAAW,CAAA,MAAA,EAA/B,aAA+B,CAA/B;AACA,SACE,OAAO,CACL;AADK,GAAP,MAAA,CAEU,IAAA,IAAA;AAAA,QAAC;AAAA,MAAA,KAAA;AAASC,MAAAA;AAAT,QAAD,IAAA;AAAA,WAAsBC,KAAK,IAALA,IAAAA,IAAiBD,KAAK,IAA5C,IAAA;AAFV,GAAA,EAGE;AACA;AAJF,GAAA,GAAA,CAKQE,MAAD,KAAa;AAChBA,IAAAA,MAAM,EADU,MAAA;AAEhBC,IAAAA,KAAK,EAAEC,mBAAmB,CACxBL,WAAW,CAACG,MAAM,CAAP,KAAA,EADa,aACb,CADa,EAAA,WAAA;AAFV,GAAb,CALP,EAYE;AACA;AAbF,GAAA,MAAA,CAcWG,IAAD,IAAUA,IAAI,CAAJA,KAAAA,IAAcP,WAAW,CAAXA,MAAAA,GAdlC,CAAA,EAeE;AAfF,GAAA,IAAA,CAgBQ,CAAA,CAAA,EAAA,CAAA,KAAUQ,CAAC,CAADA,KAAAA,GAAUC,CAAC,CAhB7B,KAAA,EAiBE;AAjBF,GAAA,GAAA,CAkBQF,IAAD,IAAUA,IAAI,CAnBvB,MACE,CADF;AAqBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,mBAAA,CAAA,CAAA,EAAA,CAAA,EAA2D;AAChE,MAAMG,OAAO,GAAGD,CAAC,CAAjB,MAAA;AACA,MAAME,OAAO,GAAGH,CAAC,CAAjB,MAAA;AACA,MAAMI,KAAY,GAAlB,EAAA;;AAEA,MAAI,CAAA,OAAA,IAAY,CAAhB,OAAA,EAA0B;AACxB,WAAA,CAAA;AAN8D,GAAA,CAShE;;;AACA,MAAIF,OAAO,GAAX,OAAA,EAAuB;AACrB,KAAA,CAAA,EAAA,CAAA,IAAS,CAAA,CAAA,EAAT,CAAS,CAAT;AAX8D,GAAA,CAchE;AACA;AACA;;;AACA,MAAID,CAAC,CAADA,OAAAA,CAAAA,CAAAA,MAAiB,CAArB,CAAA,EAAyB;AACvB,WAAOE,OAAO,GAAG,IAAjB,OAAA;AAlB8D,GAAA,CAqBhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,IAAjB,OAAA,EAA8B,EAA9B,CAAA,EAAmC;AACjCD,IAAAA,KAAK,CAALA,CAAK,CAALA,GAAW,CAAXA,CAAW,CAAXA;AACD;;AACD,OAAK,IAAIE,CAAC,GAAV,CAAA,EAAgBA,CAAC,IAAjB,OAAA,EAA8B,EAA9B,CAAA,EAAmC;AACjCF,IAAAA,KAAK,CAALA,CAAK,CAALA,CAAAA,CAAAA,IAAAA,CAAAA;AAnC8D,GAAA,CAsChE;;;AACA,OAAK,IAAIC,EAAC,GAAV,CAAA,EAAgBA,EAAC,IAAjB,OAAA,EAA8B,EAA9B,EAAA,EAAmC;AACjC,SAAK,IAAIC,EAAC,GAAV,CAAA,EAAgBA,EAAC,IAAjB,OAAA,EAA8B,EAA9B,EAAA,EAAmC;AACjCF,MAAAA,KAAK,CAALA,EAAK,CAALA,CAAAA,EAAAA,IACEH,CAAC,CAACI,EAAC,GAAHJ,CAAC,CAADA,KAAaD,CAAC,CAACM,EAAC,GAAhBL,CAAc,CAAdA,GACI,IAAIG,KAAK,CAACC,EAAC,GAAPD,CAAK,CAALA,CAAaE,EAAC,GADtBL,CACQG,CADRH,GAEIM,IAAI,CAAJA,GAAAA,CAASH,KAAK,CAALA,EAAK,CAALA,CAASE,EAAC,GAAnBC,CAASH,CAATG,EAA0BH,KAAK,CAACC,EAAC,GAAPD,CAAK,CAALA,CAHhCA,EAGgCA,CAA1BG,CAHNH;AAID;AACF;;AAED,SAAOA,KAAK,CAALA,OAAK,CAALA,CAAP,OAAOA,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,WAAA,CAAA,KAAA,EAAA,aAAA,EAGG;AACR,MAAI,CAAJ,KAAA,EAAY;AACV,WAAA,EAAA;AAFM,GAAA,CAKR;AACA;;;AACAI,EAAAA,KAAK,GAAGA,KAAK,CAALA,WAAAA,GAAAA,OAAAA,CAAAA,6BAAAA,EAARA,EAAQA,CAARA;;AAEA,MAAI,CAAJ,aAAA,EAAoB;AAClB,WAAA,KAAA;AACD;;AACD,MAAMC,iBAA+B,GAZ7B,aAYR,CAZQ,CAY+C;AAEvD;AACA;;AACA,SAAO,MAAM,CAAN,IAAA,CAAA,iBAAA,EAAA,MAAA,CAAsC,CAAA,MAAA,EAAA,YAAA,KAA0B;AACrE,QAAMC,QAAQ,GAAG,IAAA,MAAA,CAAA,YAAA,EAAjB,GAAiB,CAAjB;AACA,WAAOC,MAAM,CAANA,OAAAA,CAAAA,QAAAA,EAAyBF,iBAAiB,CAAjD,YAAiD,CAA1CE,CAAP;AAFK,GAAA,EAAP,KAAO,CAAP;AAID","sourcesContent":["import { Option } from \"./interfaces\";\n\n/**\n * A collection of string matching algorithms built with React Select in mind.\n */\n\n// Option type from React Select and similar libraries.\ntype MapOfStrings = { [key: string]: string };\n\n/**\n * Filters React Select options and sorts by similarity to a search filter.\n * Handles partial matches, eg. searching for \"Waberg High\" will find \"Raoul\n * Wallenberg Traditional High School\". Case insensitive. Ignores\n * non-alphanumeric characters.\n *\n * @param  options  An unfiltered list of Options.\n * @param? filter  A string to compare against Option labels.\n * @param? substitutions  Strings with multiple spellings or variations that we\n *           expect to match, eg. accented characters or abbreviated words.\n *\n * @return A filtered and sorted array of Options.\n */\nexport function filterOptions(\n  options: Option[],\n  filter?: string,\n  substitutions?: MapOfStrings\n): Option[] {\n  // If the filter is blank, return the full list of Options.\n  if (!filter) {\n    return options;\n  }\n\n  const cleanFilter = cleanUpText(filter, substitutions);\n  return (\n    options\n      // Filter out undefined or null Options.\n      .filter(({ label, value }) => label != null && value != null)\n      // Create a {score, Option} pair for each Option based on its label's\n      // similarity to the filter text.\n      .map((option) => ({\n        option: option,\n        score: typeaheadSimilarity(\n          cleanUpText(option.label, substitutions),\n          cleanFilter\n        ),\n      }))\n      // Only include matches of the entire substring, with a slight\n      // affordance for transposition or extra characters.\n      .filter((pair) => pair.score >= cleanFilter.length - 2)\n      // Sort 'em by order of their score.\n      .sort((a, b) => b.score - a.score)\n      // …and grab the original Options back from their pairs.\n      .map((pair) => pair.option)\n  );\n}\n\n/**\n * Scores the similarity between two strings by returning the length of the\n * longest common subsequence. Intended for comparing strings of different\n * lengths; eg. when matching a typeahead search input with a school name.\n\n * Meant for use in an instant search box where results are being fetched\n * as a user is typing.\n *\n * @param  a  The longer string (though, we flip them if it's shorter).\n * @param  b  The shorter string, eg. a typeahead search input.\n *\n * @return The length of the longest common subsequence. Higher scores indicate\n *           closer matches.\n */\nexport function typeaheadSimilarity(a: string, b: string): number {\n  const aLength = a.length;\n  const bLength = b.length;\n  const table: any[] = [];\n\n  if (!aLength || !bLength) {\n    return 0;\n  }\n\n  // Ensure `a` isn't shorter than `b`.\n  if (aLength < bLength) {\n    [a, b] = [b, a];\n  }\n\n  // Early exit if `a` includes `b`; these will be scored higher than any\n  // other options with the same `b` (filter string), with a preference for\n  // shorter `a` strings (option labels).\n  if (a.indexOf(b) !== -1) {\n    return bLength + 1 / aLength;\n  }\n\n  // Initialize the table axes:\n  //\n  //    0 0 0 0 ... bLength\n  //    0\n  //    0\n  //\n  //   ...\n  //\n  // aLength\n  //\n  for (let x = 0; x <= aLength; ++x) {\n    table[x] = [0];\n  }\n  for (let y = 0; y <= bLength; ++y) {\n    table[0][y] = 0;\n  }\n\n  // Populate the rest of the table with a dynamic programming algorithm.\n  for (let x = 1; x <= aLength; ++x) {\n    for (let y = 1; y <= bLength; ++y) {\n      table[x][y] =\n        a[x - 1] === b[y - 1]\n          ? 1 + table[x - 1][y - 1]\n          : Math.max(table[x][y - 1], table[x - 1][y]);\n    }\n  }\n\n  return table[aLength][bLength];\n}\n\n/**\n * Apply string substitutions, remove non-alphanumeric characters, and convert\n * all letters to uppercase.\n *\n * eg. 'Scoil Bhríde Primary School' may become 'SCOILBHRIDEPRIMARYSCHOOL'.\n *\n * @param  input  An unsanitized input string.\n * @param  substitutions  Strings with multiple spellings or variations that we\n *          expect to match, for example accented characters or abbreviated\n *          words.\n *\n * @return The sanitized text.\n */\nexport function cleanUpText(\n  input?: string,\n  substitutions?: MapOfStrings\n): string {\n  if (!input) {\n    return \"\";\n  }\n\n  // Uppercase and remove all non-alphanumeric, non-accented characters.\n  // Also remove underscores.\n  input = input.toUpperCase().replace(/((?=[^\\u00E0-\\u00FC])\\W)|_/g, \"\");\n\n  if (!substitutions) {\n    return input;\n  }\n  const safeSubstitutions: MapOfStrings = substitutions; // For Flow.\n\n  // Replace all strings in `safeSubstitutions` with their standardized\n  // counterparts.\n  return Object.keys(safeSubstitutions).reduce((output, substitution) => {\n    const unsubbed = new RegExp(substitution, \"g\");\n    return output.replace(unsubbed, safeSubstitutions[substitution]);\n  }, input);\n}\n"]},"metadata":{},"sourceType":"module"}