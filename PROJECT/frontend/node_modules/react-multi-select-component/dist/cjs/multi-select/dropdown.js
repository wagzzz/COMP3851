"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _useDidUpdateEffect = require("../hooks/use-did-update-effect");

var _useKey = require("../hooks/use-key");

var _useMultiSelect = require("../hooks/use-multi-select");

var _constants = require("../lib/constants");

var _selectPanel = _interopRequireDefault(require("../select-panel"));

var _cross = require("../select-panel/cross");

var _arrow = require("./arrow");

var _header = require("./header");

var _loading = require("./loading");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * A generic dropdown component.  It takes the children of the component
 * and hosts it in the component.  When the component is selected, it
 * drops-down the contentComponent and applies the contentProps.
 */
const Dropdown = () => {
  const {
    t,
    onMenuToggle,
    ArrowRenderer,
    shouldToggleOnHover,
    isLoading,
    disabled,
    onChange,
    labelledBy,
    value,
    isOpen,
    defaultIsOpen,
    ClearSelectedIcon
  } = (0, _useMultiSelect.useMultiSelect)();
  const [isInternalExpand, setIsInternalExpand] = (0, _react.useState)(true);
  const [expanded, setExpanded] = (0, _react.useState)(defaultIsOpen);
  const [hasFocus, setHasFocus] = (0, _react.useState)(false);
  const FinalArrow = ArrowRenderer || _arrow.Arrow;
  const wrapper = (0, _react.useRef)();
  (0, _useDidUpdateEffect.useDidUpdateEffect)(() => {
    onMenuToggle && onMenuToggle(expanded);
  }, [expanded]);
  (0, _react.useEffect)(() => {
    if (defaultIsOpen === undefined && typeof isOpen === "boolean") {
      setIsInternalExpand(false);
      setExpanded(isOpen);
    }
  }, [isOpen]);

  const handleKeyDown = e => {
    // allows space and enter when focused on input/button
    if (["text", "button"].includes(e.target.type) && [_constants.KEY.SPACE, _constants.KEY.ENTER].includes(e.code)) {
      return;
    }

    if (isInternalExpand) {
      if (e.code === _constants.KEY.ESCAPE) {
        var _wrapper$current;

        setExpanded(false);
        wrapper == null ? void 0 : (_wrapper$current = wrapper.current) == null ? void 0 : _wrapper$current.focus();
      } else {
        setExpanded(true);
      }
    }

    e.preventDefault();
  };

  (0, _useKey.useKey)([_constants.KEY.ENTER, _constants.KEY.ARROW_DOWN, _constants.KEY.SPACE, _constants.KEY.ESCAPE], handleKeyDown, {
    target: wrapper
  });

  const handleHover = iexpanded => {
    isInternalExpand && shouldToggleOnHover && setExpanded(iexpanded);
  };

  const handleFocus = () => !hasFocus && setHasFocus(true);

  const handleBlur = e => {
    if (!e.currentTarget.contains(e.relatedTarget) && isInternalExpand) {
      setHasFocus(false);
      setExpanded(false);
    }
  };

  const handleMouseEnter = () => handleHover(true);

  const handleMouseLeave = () => handleHover(false);

  const toggleExpanded = () => {
    isInternalExpand && setExpanded(isLoading || disabled ? false : !expanded);
  };

  const handleClearSelected = e => {
    e.stopPropagation();
    onChange([]);
    isInternalExpand && setExpanded(false);
  };

  return /*#__PURE__*/_react.default.createElement("div", {
    tabIndex: 0,
    className: "dropdown-container",
    "aria-labelledby": labelledBy,
    "aria-expanded": expanded,
    "aria-readonly": true,
    "aria-disabled": disabled,
    ref: wrapper,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdown-heading",
    onClick: toggleExpanded
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdown-heading-value"
  }, /*#__PURE__*/_react.default.createElement(_header.DropdownHeader, null)), isLoading && /*#__PURE__*/_react.default.createElement(_loading.Loading, null), value.length > 0 && /*#__PURE__*/_react.default.createElement("button", {
    type: "button",
    className: "clear-selected-button",
    onClick: handleClearSelected,
    disabled: disabled,
    "aria-label": t("clearSelected")
  }, ClearSelectedIcon || /*#__PURE__*/_react.default.createElement(_cross.Cross, null)), /*#__PURE__*/_react.default.createElement(FinalArrow, {
    expanded: expanded
  })), expanded && /*#__PURE__*/_react.default.createElement("div", {
    className: "dropdown-content"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "panel-content"
  }, /*#__PURE__*/_react.default.createElement(_selectPanel.default, null))));
};

var _default = Dropdown;
exports.default = _default;
//# sourceMappingURL=dropdown.js.map