function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * This component represents the entire panel which gets dropped down when the
 * user selects the component.  It encapsulates the search filter, the
 * Select-all item, and the list of options.
 */
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useKey } from "../hooks/use-key";
import { useMultiSelect } from "../hooks/use-multi-select";
import { KEY } from "../lib/constants";
import { debounce } from "../lib/debounce";
import { filterOptions } from "../lib/fuzzy-match-utils";
import { Cross } from "./cross";
import SelectItem from "./select-item";
import SelectList from "./select-list";
var FocusType;

(function (FocusType) {
  FocusType[FocusType["SEARCH"] = 0] = "SEARCH";
  FocusType[FocusType["NONE"] = -1] = "NONE";
})(FocusType || (FocusType = {}));

var SelectPanel = () => {
  var {
    t,
    onChange,
    options,
    setOptions,
    value,
    filterOptions: customFilterOptions,
    ItemRenderer,
    disabled,
    disableSearch,
    hasSelectAll,
    ClearIcon,
    debounceDuration,
    isCreatable,
    onCreateOption
  } = useMultiSelect();
  var listRef = useRef();
  var searchInputRef = useRef();
  var [searchText, setSearchText] = useState("");
  var [filteredOptions, setFilteredOptions] = useState(options);
  var [searchTextForFilter, setSearchTextForFilter] = useState("");
  var [focusIndex, setFocusIndex] = useState(0);
  var debouncedSearch = useCallback(debounce(query => setSearchTextForFilter(query), debounceDuration), []);
  var skipIndex = useMemo(() => {
    var start = 0;
    if (!disableSearch) start += 1; // if search is enabled then +1 to skipIndex

    if (hasSelectAll) start += 1; // if select-all is enabled then +1 to skipIndex

    return start;
  }, [disableSearch, hasSelectAll]);
  var selectAllOption = {
    label: searchText ? t("selectAllFiltered") : t("selectAll"),
    value: ""
  };

  var selectAllValues = checked => {
    var filteredValues = filteredOptions.filter(o => !o.disabled).map(o => o.value);

    if (checked) {
      var selectedValues = value.map(o => o.value);
      var finalSelectedValues = [...selectedValues, ...filteredValues];
      return options.filter(o => finalSelectedValues.includes(o.value));
    }

    return value.filter(o => !filteredValues.includes(o.value));
  };

  var selectAllChanged = checked => {
    var newOptions = selectAllValues(checked);
    onChange(newOptions);
  };

  var handleSearchChange = e => {
    debouncedSearch(e.target.value);
    setSearchText(e.target.value);
    setFocusIndex(FocusType.SEARCH);
  };

  var handleClear = () => {
    var _searchInputRef$curre;

    setSearchTextForFilter("");
    setSearchText("");
    searchInputRef == null ? void 0 : (_searchInputRef$curre = searchInputRef.current) == null ? void 0 : _searchInputRef$curre.focus();
  };

  var handleItemClicked = index => setFocusIndex(index); // Arrow Key Navigation


  var handleKeyDown = e => {
    switch (e.code) {
      case KEY.ARROW_UP:
        updateFocus(-1);
        break;

      case KEY.ARROW_DOWN:
        updateFocus(1);
        break;

      default:
        return;
    }

    e.stopPropagation();
    e.preventDefault();
  };

  useKey([KEY.ARROW_DOWN, KEY.ARROW_UP], handleKeyDown, {
    target: listRef
  });

  var handleSearchFocus = () => {
    setFocusIndex(FocusType.SEARCH);
  };

  var handleOnCreateOption = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* () {
      var newOption = {
        label: searchText,
        value: searchText,
        __isNew__: true
      }; // if custom `onCreateOption` is given then this will call this

      if (onCreateOption) {
        newOption = yield onCreateOption(searchText);
      } // adds created value to existing options


      setOptions([newOption, ...options]);
      handleClear();
      onChange([...value, newOption]);
    });

    return function handleOnCreateOption() {
      return _ref.apply(this, arguments);
    };
  }();

  var getFilteredOptions = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* () {
      return customFilterOptions ? yield customFilterOptions(options, searchTextForFilter) : filterOptions(options, searchTextForFilter);
    });

    return function getFilteredOptions() {
      return _ref2.apply(this, arguments);
    };
  }();

  var updateFocus = offset => {
    var newFocus = focusIndex + offset;
    newFocus = Math.max(0, newFocus);
    newFocus = Math.min(newFocus, options.length + Math.max(skipIndex - 1, 0));
    setFocusIndex(newFocus);
  };

  useEffect(() => {
    var _listRef$current, _listRef$current$quer;

    listRef == null ? void 0 : (_listRef$current = listRef.current) == null ? void 0 : (_listRef$current$quer = _listRef$current.querySelector("[tabIndex='" + focusIndex + "']")) == null ? void 0 : _listRef$current$quer.focus();
  }, [focusIndex]);
  var [isAllOptionSelected, hasSelectableOptions] = useMemo(() => {
    var filteredOptionsList = filteredOptions.filter(o => !o.disabled);
    return [filteredOptionsList.every(o => value.findIndex(v => v.value === o.value) !== -1), filteredOptionsList.length !== 0]; // eslint-disable-next-line
  }, [filteredOptions, value]);
  useEffect(() => {
    getFilteredOptions().then(setFilteredOptions);
  }, [searchTextForFilter, options]);
  return /*#__PURE__*/React.createElement("div", {
    className: "select-panel",
    role: "listbox",
    ref: listRef
  }, !disableSearch && /*#__PURE__*/React.createElement("div", {
    className: "search"
  }, /*#__PURE__*/React.createElement("input", {
    placeholder: t("search"),
    type: "text",
    "aria-describedby": t("search"),
    onChange: handleSearchChange,
    onFocus: handleSearchFocus,
    value: searchText,
    ref: searchInputRef,
    tabIndex: 0
  }), /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: "search-clear-button",
    hidden: !searchText,
    onClick: handleClear,
    "aria-label": t("clearSearch")
  }, ClearIcon || /*#__PURE__*/React.createElement(Cross, null))), /*#__PURE__*/React.createElement("ul", {
    className: "options"
  }, hasSelectAll && hasSelectableOptions && /*#__PURE__*/React.createElement(SelectItem, {
    tabIndex: skipIndex === 1 ? 0 : 1,
    checked: isAllOptionSelected,
    option: selectAllOption,
    onSelectionChanged: selectAllChanged,
    onClick: () => handleItemClicked(1),
    itemRenderer: ItemRenderer,
    disabled: disabled
  }), filteredOptions.length ? /*#__PURE__*/React.createElement(SelectList, {
    skipIndex: skipIndex,
    options: filteredOptions,
    onClick: (_e, index) => handleItemClicked(index)
  }) : isCreatable ? /*#__PURE__*/React.createElement("li", {
    onClick: handleOnCreateOption,
    className: "select-item creatable"
  }, t("create") + " \"" + searchText + "\"") : /*#__PURE__*/React.createElement("li", {
    className: "no-options"
  }, t("noOptions"))));
};

export default SelectPanel;
//# sourceMappingURL=index.js.map